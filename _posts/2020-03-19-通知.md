---
title: 通知
background_music: '<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=29207835&auto=1&height=66"></iframe>'
tags:
- 通知
---
- 今天是难受的一天
>博客崩溃难受啊！
>>正在努力刷黑客排名！
>>>**各位都是我的访问者，不要一看就走了，我还没被百度收录呢QAQ**
- 评论一下吧<script src="https://utteranc.es/client.js"
        repo="2398954487/pinlunchucun"
        issue-term="pathname"
        theme="icy-dark"
        crossorigin="anonymous"
        async>
</script>



//哈密顿绕行世界问题
#include<bits/stdc++.h>
using namespace std;
 
const int maxn = 25;
bool city[maxn][maxn], vis[maxn]; //表示两个城市间是否能走, 表示一个城市是否走过
int path[maxn], m, no; //路径
void Dfs(int from, int cont)
{
    path[cont] = from;
    if(cont == 20){ //走完了20个城市
        if(city[from][m]){ // 是否到m的路为通路, 打印结果
            printf("%d: ",no++);
            for(int i = 1; i <= 20; i++)
                printf(" %d",path[i]);
            printf(" %d\n", m);
        }
        return;
    }
    //为了从小到大按字典序输出, 对于每个城市我们都判断是否有通路且未走过
    for(int i = 1; i <= 20; i++)
        if(city[from][i] && !vis[i]){
            vis[i] = 1;
            Dfs(i, cont+1);
            vis[i] = 0; //回溯
        }
}
 
int main()
{
    int i1, i2, i3;
    for(int i = 1; i <= 20; i++){
        scanf("%d%d%d",&i1,&i2,&i3);
        city[i][i1] = 1, city[i][i2] = 1, city[i][i3] = 1;//两城市之间为通路
    }
    while(scanf("%d",&m),m){
        memset(vis, 0, sizeof(vis)), memset(path, 0, sizeof(path));
        no = 1, vis[m] = 1;
        Dfs(m, 1); //初始状态, 从第m个城市出发
    }
    return 0;
}
